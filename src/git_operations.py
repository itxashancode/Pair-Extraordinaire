import subprocess
from pathlib import Path
from datetime import datetime
import logging
from typing import List, Optional

logger = logging.getLogger(__name__)


class GitOperations:
    """Windows-optimized Git operations using subprocess"""

    def __init__(self, config, repo_path="."):
        """
        Initialize Git operations
        
        Args:
            config: ConfigManager instance
            repo_path: Path to git repository
        """
        self.config = config
        self.repo_path = Path(repo_path).resolve()
        self._verify_git_repo()

    def _verify_git_repo(self):
        """Verify that the current directory is a git repository"""
        try:
            self._run_git(["status", "--porcelain"])
            logger.debug(f"Verified git repository at {self.repo_path}")
        except RuntimeError:
            raise RuntimeError(f"Not a git repository: {self.repo_path}")

    def _run_git(self, args: List[str], check: bool = True) -> str:
        """
        Run git command with proper error handling
        
        Args:
            args: Git command arguments
            check: Whether to check return code
        
        Returns:
            Command output
            
        Raises:
            RuntimeError: If git command fails
        """
        try:
            result = subprocess.run(
                ["git"] + args,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                shell=True,  # Required for Windows
                timeout=30
            )

            if check and result.returncode != 0:
                error_msg = result.stderr.strip() or f"Git command failed: {' '.join(args)}"
                raise RuntimeError(error_msg)

            if result.stdout:
                logger.debug(f"Git output: {result.stdout.strip()[:200]}")

            return result.stdout.strip()

        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Git command timed out: {' '.join(args)}")
        except Exception as e:
            raise RuntimeError(f"Failed to run git command: {e}")

    def create_branch(self, branch_name: str):
        """
        Create and switch to a new branch
        
        Args:
            branch_name: Name of the branch to create
        """
        default_branch = self.config.get_repo_config().get("default_branch", "main")

        logger.info(f"Creating branch: {branch_name} from {default_branch}")

        # Fetch latest changes
        self._run_git(["fetch", "--all"])

        # Checkout default branch and pull latest
        self._run_git(["checkout", default_branch])
        self._run_git(["pull", "origin", default_branch])

        # Create and switch to new branch
        self._run_git(["checkout", "-b", branch_name])

        logger.info(f"Successfully created branch: {branch_name}")

    def modify_files(self, files: List[str]) -> List[str]:
        """
        Modify specified files
        
        Args:
            files: List of file paths to modify
            
        Returns:
            List of successfully modified files
        """
        modified = []
        timestamp = datetime.now()

        for file_path in files:
            try:
                full_path = self.repo_path / file_path
                full_path.parent.mkdir(parents=True, exist_ok=True)

                # Append timestamp to file
                with open(full_path, "a", encoding="utf-8", newline="\n") as f:
                    f.write(f"\n# Auto-updated on {timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n")

                modified.append(file_path)
                logger.debug(f"Modified file: {file_path}")

            except Exception as e:
                logger.error(f"Failed to modify file {file_path}: {e}")
                raise

        return modified

    def commit(self, files: List[str], coauthor: dict):
        """
        Commit modified files with proper co-author formatting
        
        Args:
            files: List of files to commit
            coauthor: Co-author configuration with 'name' and 'email'
        """
        if not files:
            logger.warning("No files to commit")
            return

        # Stage files
        for file_path in files:
            self._run_git(["add", file_path])
            logger.debug(f"Staged file: {file_path}")

        # Create commit message with proper co-author format
        # IMPORTANT: GitHub requires:
        # 1. Commit title (first line)
        # 2. Blank line
        # 3. Commit body (optional)
        # 4. Blank line
        # 5. Co-authored-by trailers
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        message = f"""Automated PR Update - {timestamp}

This commit was automatically generated by Auto PR Creator.
Changes made to {len(files)} file(s).

Co-authored-by: {coauthor['name']} <{coauthor['email']}>
"""
        # Commit with the formatted message
        # Using -m with a multi-line string works correctly in git
        self._run_git(["commit", "-m", message])
        
        # Verify the commit message format
        logger.debug(f"Commit message format:\n{message}")
        logger.info(f"Committed {len(files)} files with co-author: {coauthor['name']}")

    def push(self, branch_name: str):
        """
        Push branch to remote
        
        Args:
            branch_name: Name of the branch to push
        """
        self._run_git(["push", "-u", "origin", branch_name])
        logger.info(f"Pushed branch: {branch_name} to origin")

    def get_current_branch(self) -> str:
        """Get current branch name"""
        return self._run_git(["rev-parse", "--abbrev-ref", "HEAD"])

    def has_changes(self) -> bool:
        """Check if there are uncommitted changes"""
        status = self._run_git(["status", "--porcelain"])
        return bool(status.strip())